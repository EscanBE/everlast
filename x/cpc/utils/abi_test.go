package utils

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/require"
)

func TestAbiEncode(t *testing.T) {
	t.Run("single string", func(t *testing.T) {
		bz, err := AbiEncodeString("test")
		require.NoError(t, err)
		require.Equal(t, []byte{
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20,
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4,
			0x74, 0x65, 0x73, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		}, bz)

		v, err := AbiDecodeString(bz)
		require.NoError(t, err)
		require.Equal(t, "test", v)
	})

	t.Run("single uint8", func(t *testing.T) {
		bz, err := AbiEncodeUint8(8)
		require.NoError(t, err)
		require.Equal(t, []byte{
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8,
		}, bz)

		v, err := AbiDecodeUint8(bz)
		require.NoError(t, err)
		require.EqualValues(t, 8, v)
	})

	t.Run("single uint256", func(t *testing.T) {
		bz := make([]byte, 32)
		bz[0] = 0xff
		uint256 := new(big.Int).SetBytes(bz)

		bz, err := AbiEncodeUint256(uint256)
		require.NoError(t, err)
		require.Equal(t, []byte{
			0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		}, bz)

		v, err := AbiDecodeUint256(bz)
		require.NoError(t, err)
		require.Equal(t, uint256.String(), v.String())
	})

	t.Run("single bool", func(t *testing.T) {
		bz, err := AbiEncodeBool(true)
		require.NoError(t, err)
		require.Equal(t, []byte{
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
		}, bz)

		v, err := AbiDecodeBool(bz)
		require.NoError(t, err)
		require.Equal(t, true, v)
	})

	t.Run("single array of addresses", func(t *testing.T) {
		addr1 := common.HexToAddress("0x7b5fe22b5446f7c62ea27b8bd71cef94e03f3df1")
		addr2 := common.HexToAddress("0xc1201f3dd7570101dd219c6dc5f042a83b9dc9ed")
		bz, err := AbiEncodeArrayOfAddresses([]common.Address{addr1, addr2})
		require.NoError(t, err)
		require.Equal(t, []byte{
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20,
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2,
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7b, 0x5f, 0xe2, 0x2b, 0x54, 0x46, 0xf7, 0xc6, 0x2e, 0xa2, 0x7b, 0x8b, 0xd7, 0x1c, 0xef, 0x94, 0xe0, 0x3f, 0x3d, 0xf1,
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc1, 0x20, 0x1f, 0x3d, 0xd7, 0x57, 0x1, 0x1, 0xdd, 0x21, 0x9c, 0x6d, 0xc5, 0xf0, 0x42, 0xa8, 0x3b, 0x9d, 0xc9, 0xed,
		}, bz)

		v, err := AbiDecodeArrayOfAddresses(bz)
		require.NoError(t, err)
		require.Equal(t, []common.Address{addr1, addr2}, v)
	})
}
